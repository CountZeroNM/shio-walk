# 開発メモ MD
# Debug Notes / 引き継ぎ用デバッグノート

本ドキュメントは **shio-walk プロジェクトにおける長期デバッグの記録と設計判断の背景** をまとめたものです。  
README には書ききれない「考え方」「学び」「再発防止策」を中心に記載します。

---

## 1. 本プロジェクトの前提思想（超重要）

### Single Source of Truth

本プロジェクトでは **バックエンド API を唯一の信頼できる情報源（Single Source of Truth）** とします。

- フロントエンドでのデータ補正・吸収は原則禁止
- 不整合があった場合は **必ず API 側を修正**
- フロントエンドは「受け取ったデータをそのまま描画する」責務に限定する

この方針を守らない場合、以下の問題が発生します：

- re-frame の state が壊れる
- UI が一瞬遷移して元に戻る
- デバッグが指数関数的に困難になる

---

## 2. 今回の不具合概要（要約）

### 症状

- ウォーキング開始ボタンを押す
- 一瞬「ウォーキング中UI」に遷移
- すぐに元の画面に戻る
- API は成功レスポンスを返している
- エラーは出ない、もしくは warning のみ

### 結論

**単一のバグではなく、複数の不整合が連鎖した状態不整合（レースコンディション）**

---

## 3. 実際に起きていた問題

### API レスポンスの揺れ

- `status`
  - `"active"` と `"in_progress"` が混在
- key 命名
  - `snake_case` と `kebab-case` が混在
- 数値フィールド
  - `steps`, `distance-meters` が `nil` になるケース
- 一部データで
  - `id` が `nil`

### フロントエンド側の状態

- optimistic update により UI が先に切り替わる
- 直後に `load-walks` で API データが流入
- 不整合なデータで state が上書きされ UI が巻き戻る

---

## 4. 設計判断（なぜこの修正を選んだか）

### 選択肢

- ❌ フロントエンドで吸収する
- ⭕ API 契約を正す

### 判断理由

- フロントで吸収すると：
  - 不具合が隠蔽される
  - 別画面・別開発者で再発する
  - 将来のデバッグコストが爆増する
- API 契約を正すと：
  - re-frame の状態管理が単純になる
  - UI 巻き戻りが構造的に起きなくなる
  - 引き継ぎが容易になる

**短期的コストより、長期的安全性を優先**

---

## 5. コーディング上の重要な学び（核心）

### 5.1 re-frame の UI 巻き戻りは「ほぼ state 不整合」

以下の症状が揃ったら、まず疑う：

- 一瞬だけ UI が切り替わる
- API は成功している
- エラーが出ない

👉 **state が二重に更新されている可能性が極めて高い**

---

### 5.2 optimistic update は強力だが危険

optimistic update とは：

> API 成功を仮定して UI を先に更新する手法

前提条件：

- API レスポンスが **完全に安定していること**
- status / key / 値が揺れないこと

これが守られないと、**UI 巻き戻り製造機** になる。

---

### 5.3 「フロントで吸収」は将来の自分を殺す

書きがちなコード：

```clojure
(or (:distance-meters walk) 0)


これは：

API の破綻を隠す

問題を別箇所へ拡散する

後続開発者を混乱させる

👉 正解は API 側で必ず値を保証する


---
## 6. 再発防止チェックリスト（実務用）
### API 側チェック

- key はすべて kebab-case

- id は必ず存在する

- 数値フィールドは nil を返さない

- status は固定値のみ（例: "active", "completed"）

- start/update/complete でレスポンス構造が一致している

### フロントエンド側チェック（re-frame）

- 同じ event-id を複数回 reg-event-* していない

- optimistic update と API 更新が競合していない

- load-* 系イベントが state を意図せず上書きしていない

- current-* 系 state が API データで壊されていない

---

デバッグ時の確認順序（推奨）

API の raw response を console に出す

key / status / nil の有無を確認

re-frame の event 発火順を追う

「どの event が最後に state を書き換えたか」を特定

フロントを直す前に API 契約を疑う

---
7. README / JSON 手順書との関係

README

設計方針・全体像・公式な仕様

本ドキュメント（debug-notes.md）

判断理由・学び・失敗と回復の記録

debugging-handover.json

実務用の手順・チェック・確認順

👉 Why / What / How を分離 して管理する

8. 最後に（未来の自分・引き継ぎ者へ）

この不具合は「re-frameが難しい」から起きたのではない。
契約が曖昧なまま optimistic な設計をした結果 起きた。

この記録が、

同じ罠に二度落ちない

状態管理に自信を持てる

「直し方」ではなく「考え方」を継承できる

ための助けになれば幸いである。
